## RxJS

来源 `Reactive Extension`，源自微软，火于 `NetFlix`，一个基本的例子

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title></title>
</head>
<body>

  <div> <input type="number" id="length"></div>

  <div><input type="number" id="width"></div>

  <div id="area"></div>

<script src="https://unpkg.com/@reactivex/rxjs@5.0.3/dist/global/Rx.js"></script>
<script>

  const length = document.querySelector('#length')
  const width = document.querySelector('#width')
  const area = document.querySelector('#area')

  // 监听 keyup 事件，并取得 target.value
  const length$ = Rx.Observable.fromEvent(length, 'keyup').pluck('target', 'value')
  const width$ = Rx.Observable.fromEvent(width, 'keyup').pluck('target', 'value')

  // 想要得到结果，需要做一个合并
  // 这里的 combineLatest 可以换成 zip
  const area$ = Rx.Observable.combineLatest(length$, width$, (l, w) => {
    return l * w
  })
  
  // 得到结果，放入 area 中
  area$.subscribe(val => area.innerHTML = val)

</script>
</body>
</html>
```

根据时间序列划分上面的示例

```
lenght:  ----1------------------3

width:   ------------2-----------

area:    ----------(2, 1)-----(2, 3)

                    2*1        2*3

返回结果： ------------2----------6
```

* 每个 `Observable` 都可以看成一个数据流

* `combineLatest` 的作用是两个输入框都需要有值的情况下才会计算结果

* `zip` 同上面的一样，也是需要都有值的情况下才会计算结果，但是必须是要有**新值**

替换成 `zip` 以后的时间序列

```
lenght:  ----1------------------3---------

width:   ------------2--------------------3

area:    ----------(2, 1)---------------(3, 3)

                    2*1                  3*3

返回结果： ------------2--------------------9
```



## RxJS 中常见的操作符

#### 创建类操作符

* `from`

可以把数组，`Promise`，以及 `Iterable` 转化为 `Observable`

```js
Rx.Observable.from([1, 2, 3, 4])
```

这样操作以后，每次返回的结果均为 `4`，因为序列流很快的就执行完了，最后的一次结果为 `4`

* `fromEvent`

把事件转化为 Observable

* `of`

接收一系列数据，并把它们 `emit` 出去，它可以接收对象

```js
const length$ = Rx.Observable.of({id: 1, value: 20})

const area$ = Rx.Observable.combineLatest(length$, width$, (l, w) => l.value * w)
```

如果是

```js
const length$ = Rx.Observable.of({id: 1, value: 20}, {id: 2, value: 30})
```

那么这个结果返回的 `value` 是 `30`（同 `from` 那个示例一致）



#### 转换操作符

`map`, `mapTo`, `pluck`

简单来说

```js
// 之前的示例
Rx.Observable.fromEvent(length, 'keyup').pluck('target', 'value')

// ==> 等同于

Rx.Observable.fromEvent(length, 'keyup').map( ev => ev.target.value)
```

`fromEvent` 返回的是一个 `event` 对象，`pluck` 可以理解为 `map` 的简化版本，而对于 `maoTo`：

```js
// 如果之前的示例中调整为这样的话，无论输入什么值，返回的值固定为 2
Rx.Observable.fromEvent(length, 'keyup').mapTo(1)
Rx.Observable.fromEvent(width, 'keyup').mapTo(2)

// ==> 等同于，因为不关心返回了哪些值
Rx.Observable.fromEvent(length, 'keyup').map( _ => 1)
```

它传递的是一个常量，不需要去关心返回了什么，一般用来标记，比如点击了几次